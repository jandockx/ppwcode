#summary Usage of Subversion by the ppwcode project
#labels Phase-Implementation

= Introduction =

Subversion is a beautiful tool. You can do al kinds of things with it. But, we need some consistency. In this document we describe how we want to use Subversion (and why).


= Subprojects =

While it was already possible in CVS to use deep directory structures, for a number of reasons it was practical to have different projects as peer on the top level of a repository. Subversion however much more resembles an ordinary file system, where directory structures are really that.

Therefor, we use deep structures to nest projects in a context of related projects.

== Nominal structure ==

On the first level, we discern between different targets. For libraries, these targets are the technologies (Java, .net, ...). Then, within such a target directory, further structuring depends on the vernaculars of those targets. On this level you also find the general projects `licenses`, `logo`, `website` and `wiki` (which must be here to work with Google Code).

== Special subtrees ==

Special subtrees are available in the svn repository with names starting with "`_`".

  * `_purgatory`: here old versions of projects of ours reside (which were imported at the start of ppwcode from the old CVS repository) for reactivation; this directory will normally go away after a while
  * `_tmp`: just what it says: a home for temporary storage; please clean up after yourself
  * `_sandbox`: where new projects live, before they are mature enough to know there way in the main structure
  * `_renditions`: where the above directories are intended mainly for developers and contributors, this one is for everybody; it contains different "renditions" of this repository, different ways of presenting it, for different audiences or tools



= Tags and Branches =

Tags and branches _an sich_ or not a feature of Subversion as they where a feature from CVS. But with the features that do exist in Subversion, notably the "_zeitliche_ copy" ([http://www.kfs.org/~jonathan/witt/t64311en.html see Wittgenstein, Tractatus Logico Philosophicus, 6.4.3.1.1] :-P) make this, and more, possible in a more transparant way.


== The conventional way ==

The "conventional" way to do tags and branches with Subversion, is to create, under your project root, a `trunk` directoryt, for the, uhm, trunk of development, a `branches` directory for the branches, and a `tags` directory for, you guessed it, the tags:
  * myProjectSvn/
    * trunk/
    * branches/
      * aBranch/
      * anotherBranch/
      * aDevelopmentBranch/
      * 1.0.0PatchBranch/
      * 2.0.0PatchBranch/
      * 2.1.0PatchBranch/
      * 2.2.0PatchBranch/
      * 3.0.0PatchBranch/
    * tags/
      * d1
      * d2
      * d3
      * d4
      * d4bis
      * d5
      * d6
      * ...
      * d1254
      * 1.0.0-alpha-1/
      * 1.0.0-alpha-2/
      * 1.0.0-alpha-3/
      * 1.0.0-alpha-4/
      * 1.0.0-alpha-5/
      * 1.0.0-beta-1/
      * 1.0.0-beta-2/
      * 1.0.0-rc-1/
      * 1.0.0-rc-2/
      * 1.0.0/
      * 1.0.1/
      * 1.0.2/
      * 1.1.0/
      * 1.1.1/
      * 1.1.2/
      * 1.2.0/
      * 2.0.0/
      * 2.0.1/
      * 2.1.0/
      * 2.1.1/
      * 2.1.2/
      * 2.1.3/
      * 2.1.4/
      * 2.1.5/
      * 2.2.0/
      * 2.2.1/
      * 3.0.0/
      * aBranchRoot/
      * anotherBranchRoot/
      * aDevelopmentBranchRoot/
      * 1.0.0PatchBranchRoot/
      * 2.0.0PatchBranchRoot/
      * 2.1.0PatchBranchRoot/
      * 2.2.0PatchBranchRoot/
      * 3.0.0PatchBranchRoot/

Or something like that, probably even much more complex. Note in any case that version numbers do have dots in them, and the `-`-symbol, and start with a number, things that were impossible with CVS.

We contend that working with the tags and branches directory is left-over of the CVS days, and that we can do much better. Convention over configuration, sure, but in practice the "`trunk` - `branches` - `tags`" convention is not very well supported in tools anyway (yes, with the exception of TortoiseSVN).


== Nested version tags ==

Now, the first thing that we observe is a hierarchical structure in the version numbers. Whatever your criteria for dot-versions are, you are using a dotted scheme, aren't you? We too. With CVS, the tags and branches name space is flat, and there is nothing you can do about that. With Subversion however, "tags" and "branches" are merely directories, normally a copy-in-time of the trunk. And directory names are relatively free format. So, with this new technology, there is no need to limit ourself to an endless flat list. Instead, we can represent the dot-version hierarchy as a ... hierarchy. This is much easier for developers and users to navigate and understand, and we do not need idiotic prefixes.

And, since next to the trunk and a `dev` directory, we only have version tags, there is no need to store the dot-version tags in a separate directory. With the above example, the tree would look like this (the rest of the original tree will dissolve in a moment):

  * myProjectSvn/
    * trunk/
    * 1.n.n/
      * 1.0.n/
        * 1.0.0-alpha/
          * 1.0.0-alpha-1/
          * 1.0.0-alpha-2/
          * 1.0.0-alpha-3/
          * 1.0.0-alpha-4/
          * 1.0.0-alpha-5/
        * 1.0.0-beta/
          * 1.0.0-beta-1/
          * 1.0.0-beta-2/
        * 1.0.0-rc/
          * 1.0.0-rc-1/
          * 1.0.0-rc-2/
        * 1.0.0/
        * 1.0.1/
        * 1.0.2/
      * 1.1.n/
        * 1.1.0/
        * 1.1.1/
        * 1.1.2/
      * 1.2.n/
        * 1.2.0/
    * 2.n.n/
      * 2.0.n/
        * 2.0.0/
        * 2.0.1/
      * 2.1.n/
        * 2.1.0/
        * 2.1.1/
        * 2.1.2/
        * 2.1.3/
        * 2.1.4/
        * 2.1.5/
      * 2.2.n
        * 2.2.0/
        * 2.2.1/
    * 3.n.n.
      * 3.0.n/
        * 3.0.0/
    * branches/
      * aBranch/
      * anotherBranch/
      * aDevelopmentBranch/
      * 1.0.0PatchBranch/
      * 2.0.0PatchBranch/
      * 2.1.0PatchBranch/
      * 2.2.0PatchBranch/
      * 3.0.0PatchBranch/
    * tags/
      * d1
      * d2
      * d3
      * d4
      * d4bis
      * d5
      * d6
      * ...
      * d1254


== Branches and branch root tags ==

Let's turn to branches. With CVS, it was in practice quite important to create a branch at the time your trunk is at the branch point. It was possible, but quite difficult, to create a branch retro-actively. Not so with Subversion. Furthermore, it was also quite important, when branching, to also create a tag at the branch point, i.e., the "root" of the branch (to be able to make sensible diffs when you want to merge a branch into the trunk later on). Not so with Subversion, for the simple reason that a tag is the same as a branch: a copy-in-time of a directory, that knows of itself when it was copied.

When we look at the reason for branching, we find essentially 2 reasons:
  * to evolve the code of an old version, while the trunk already has moved on (maintenance release, bugfix, backporting new features into a backward compatible release, ...)
  * to do extended experiments, try dangerous things, in a sandbox, without interfering with or interference from other developers

Again, these 2 reasons are of a different nature. Here we will talk about *Evolution of an old version (patch branches)*

What happens in practice is that you released, and tagged a version, moved on, and that after some weeks or months, you get a bug report, an enhancement request, or find another reason to do a minor upgrade, on the old code. For a number of reasons you don't want to force your users to use the latest version, but you want to do minimal changes on the old version. Now, with Subversion, if you have a directory that is the copy-in-time of that release, which is since unchanged and should stay unchanged, _it is a breeze to create a new copy of that directory now that you need it_, to work on. And, by the way, for this development, this is really a "trunk".

So, with Subversion, _there is no need to create branches when you release a new version_. The tag suffices. And _there is no need to create a branch root tag either_.

Now, if you store your dot-version tags in a hierachy, it is also clear where this "version trunk" should appear: next to the tag you are copying from. Suppose you have a `major.minor.micro` version number. You will always work _starting from a micro version_, possible 0, since that is what you release. In this kind of work, you know what your intention is: create a bugfix (new micro version, same minor version), or backport a new feature e.g., (new minor version, same major version). (You will, in this mode, never create a new major version).

If your intention is to create a new micro version, you will always want to start from the latest micro version for that minor version. Copy that directory to a `trunk` directory under that minor version, and work there. Or, maybe you did that last time, and there already is a trunk. But in that case, that is exactly where you should continue working. If you started that minor-version-trunk at version n.m.k, you released n.m.k+1, and maybe also, n.m.k+2, and so on. In any case, there is no deeper nesting, so work for all releases later than k for minor version n.m has been done on this trunk, so the trunk, if it exists, is at the latest micro version.

If your intention is to create a new minor version, exactly the same applies, except that you might want to merge changes from the last minor trunk into the major trunk before starting.

For our example, where there were retroactive fixes at some points, but not all, this leads to the following structure:



  * myProjectSvn/
    * trunk/
    * 1.n.n/
      * 1.0.n/
        * 1.0.0-alpha/
          * 1.0.0-alpha-1/
          * 1.0.0-alpha-2/
          * 1.0.0-alpha-3/
          * 1.0.0-alpha-4/
          * 1.0.0-alpha-5/
        * 1.0.0-beta/
          * 1.0.0-beta-1/
          * 1.0.0-beta-2/
        * 1.0.0-rc/
          * 1.0.0-rc-1/
          * 1.0.0-rc-2/
        * 1.0.0/
        * 1.0.1/
        * 1.0.2/
        * trunk
      * 1.1.n/
        * 1.1.0/
        * 1.1.1/
        * 1.1.2/
      * 1.2.n/
        * 1.2.0/
    * 2.n.n/
      * 2.0.n/
        * 2.0.0/
        * 2.0.1/
        * trunk
      * 2.1.n/
        * 2.1.0/
        * 2.1.1/
        * 2.1.2/
        * 2.1.3/
        * 2.1.4/
        * 2.1.5/
        * trunk
      * 2.2.n
        * 2.2.0/
        * 2.2.1/
        * trunk
      * trunk
    * 3.n.n.
      * 3.0.n/
        * 3.0.0/
    * branches/
      * aBranch/
      * anotherBranch/
      * aDevelopmentBranch/
    * tags/
      * d1
      * d2
      * d3
      * d4
      * d4bis
      * d5
      * d6
      * ...
      * d1254

== Experiment branches and development tags ==

How about branches the developer makes, to not interfere with or be interfered by other developers?
And, how about development tags? Normally, you would want to tag your trunk when it is stable during development too, e.g., when you make a snapshot build. This is definitely another "kind" of tag, with another finality and another audience than the dot-version tags. It would make sense to gather them together, these tags, and branches, separate from the others.

Well, given the previous, this is actually simple: these kinds of tags always happen in the context of _a_ trunk. We suggest putting a `dev` directory next to the trunk, and creating the development tags there. Instead of a sequence number, we will use the date-hour format, because this makes it easier to situate the tag in time, and to relate it to Maven-generated snapshots build, that use the same format. With that, our Subversion tree will look like this:

  * myProjectSvn/
    * trunk/
    * dev
      * d20040712-1245
      * d20040712-1618
      * d20040713-2314
      * ...
      * d20041114-0136
    * 1.n.n/
      * 1.0.n/
        * 1.0.0-alpha/
          * 1.0.0-alpha-1/
          * 1.0.0-alpha-2/
          * 1.0.0-alpha-3/
          * 1.0.0-alpha-4/
          * 1.0.0-alpha-5/
        * 1.0.0-beta/
          * 1.0.0-beta-1/
          * 1.0.0-beta-2/
        * 1.0.0-rc/
          * 1.0.0-rc-1/
          * 1.0.0-rc-2/
        * 1.0.0/
        * 1.0.1/
        * 1.0.2/
        * trunk
        * dev
          * d20060113-0734
          * d20060113-0934
          * d20060116-1228
          * d20060201-0714
          * d20060527-1055
          * d20060528-1321
      * 1.1.n/
        * 1.1.0/
        * 1.1.1/
        * 1.1.2/
      * 1.2.n/
        * 1.2.0/
    * 2.n.n/
      * 2.0.n/
        * 2.0.0/
        * 2.0.1/
        * trunk
        * dev
          * ...
      * 2.1.n/
        * 2.1.0/
        * 2.1.1/
        * 2.1.2/
        * 2.1.3/
        * 2.1.4/
        * 2.1.5/
        * trunk
        * dev
          * ...
      * 2.2.n
        * 2.2.0/
        * 2.2.1/
        * trunk
        * dev
          * ...
      * trunk
        * dev
          * ...
    * 3.n.n.
      * 3.0.n/
        * 3.0.0/
    * branches/
      * aBranch/
      * anotherBranch/
      * aDevelopmentBranch/

Note that there is no more `tags`-directory.

Finally, we are left with the development branches.