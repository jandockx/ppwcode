#summary How to deal with bidirectional associations with persistence and serialization
#labels Phase-Vernacular



= Introduction =

The context of this discussion is how to deal with bidirectional relationships in a 2-faces context, with persistence on one side, and use of the semantic objects outside of the persistence context on the other side.

The problem is the same in the context of EJB2, HIbernate, JPA, or any other persistence technology (and EJB3 / JPA does not solve it). The problem is the same in the context of any use of the semantic objects out side the persistence context. In particular, when the semantic objects are transported from one system to another, via serialization, XML or other marshalling, JSON conversion, with RMI, web services, dwr, or any other technology.

There is no good solution to date that we can think of. In this text, we take down different possible approaches, and discuss their benefits and negative points. Finally, we choose one approach, which does not solve the problem completely, as our vernacular.


= The example =

We will use an example in this text to make things more clear. We will consider a bidirectional one-to-many relation between enterprises and contracts (one enterprise has 0-n contracts, a contract has 0-1 enterprise). Although a civilized contract cannot exist without an enterprise, it can exist in RAM as a non-civil contract. This is necessary for a number of reasons, amongst others, because we need a contract object a priori during creation, to set an enterprise on (creation is a slow, user interactive proces). A normal Java implementation would be:

{{{
public class Enterprise {

  /*<property name="contracts">
  -------------------------------------------------------------------------*/

  @MethodContract(pre  = {@Expression("_c != null"),
                          @Expression("_c.enterprise == this")},
                  post = @Expression("contracts.contains(_c)"))
  final void addContract(Contract c) {
    ProgrammingErrors.preArgumentNotNull(c, "c");
    $contracts.add(c);
  }

  @MethodContract(post = @Expression("! contracts.contains(_c)"))
  final void removeContract(Contract c) {
    $contracts.remove(c);
  }

  @Basic(init   = @Expression("contracts.isEmpty()"),
         invars = {@Expression("contracts != null"),
                   @Expression("! contracts.contains(null)"),
                   @Expression("for (Contract c : contracts) { c.enterprise == this }")})
  final public Set<Contract> getContracts() {
    return new HashSet<Contract>($contracts);
  }

  @Invars({@Expression("$contracts != null"),
           @Expression("! $contracts.contains(null)"),
           @Expression("for (Contract c : $contracts) { c.enterprise == this }")})
  private Set<Contract> $contracts = new HashSet<Contract>();

  /*</property>*/

}
}}}
{{{
public class Contract {

  /*<property name="Enterprise">
  -------------------------------------------------------------------------*/

  @Basic(init   = @Expression("enterprise == null"),
         invars = @Expression("enterprise != null ? enterprise.contracts.contains(this)"))
  public final Enterprise getEnterprise() {
    return $enterprise;
  }

  @MethodContract(post = {@Expression("enterprise == _enterprise"),
                          @Expression("'enterprise != null ? ! 'enterprise.contracts.contains(this)"),
                          @Expression("_enterprise != null ? _enterprise.contracts.contains(this)")})
  public final void setEnterprise(Enterprise enterprise) {
    if ($enterprise != enterprise) {
      if ($enterprise != null) {
        $enterprise.removeContract(this);
      }
      $enterprise = enterprise;
      if ($enterprise != null) {
        $enterprise.addContract(this);
      }
    }
  }

  private Enterprise $enterprise;

  /*</property>*/

}
}}}



= The need for bidirectional associations =

Bidirectional associations are, in general needed for our semantics. One possible solution of the problem, is to not work with bidirectional associations, but replace them with unidirectional relations, as follows:

{{{
public class Enterprise {

  // NOP

}
}}}
{{{
public class Contract {

  /*<property name="Enterprise">
  -------------------------------------------------------------------------*/

  @Basic(init = @Expression("enterprise == null"))
  public final Enterprise getEnterprise() {
    return $enterprise;
  }

  @MethodContract(post = @Expression("enterprise == _enterprise"))
  public final void setEnterprise(Enterprise enterprise) {
    $enterprise = enterprise;
  }

  private Enterprise $enterprise;

  /*</property>*/

}
}}}

This might work, but now we have lost a lot, which can not easily be replaced. A lot of the semantics of enterprises and contracts is in their structure, but an equal amount of semantics is expressed in extra invariants, which result in _validation code_. In our vernacular, this validation code turns up in the setter (in this case `Contract.setEnterprise(Enterprise)` and in the `Contract.wildExceptions` and `Enterprise.wildExceptions` methods, which test civility.

Whenever an invariant expresses limitations on the set of contracts for an enterprise, we are in trouble. Imagine, e.g., a business rule that says that contracts, which have a start and an end date, for a given enterprise, may not overlap. In the original code, this invariant would be expressed in Enterprise, and be of the form:
{{{
for (Contract c1 : contracts) {for (Contract c2: contracts) {c1 != c2 ?? noOverlap(c1, c2)}}
}}}
This invariant would be enforced by adding validation code to `Contract.setEnterprise(Enterprise)`:
{{{
}}}

In the version with a unidirectional association, there is no way we can express this invariant in an encapsulated way.

We could add an invariant instead on Enterprise of the form:
{{{
for (Contract c1) {for (Contract c2) {c1.enterprise = this && c2.enterprise == this && c1 != c2 ?? noOverlap(c1, c2)}}
}}}

This is correct in the contract paradigm. The problem is that we have no way to implement this in a rational way. 