dojo.provide("ppwcode.dojo.dijit.form.CrudForm");

dojo.require("ppwcode.dojo.dijit.form.ObjectForm");
dojo.require("dijit.form.Button");
dojo.require("dijit.Tooltip");
dojo.require("dojo.i18n");
dojo.requireLocalization("ppwcode.dojo.dijit.form", "CrudForm");


dojo.declare(
	"ppwcode.dojo.dijit.form.CrudForm",
	ppwcode.dojo.dijit.form.ObjectForm,
	{
		// summary:
		//   The CrudForm builds on dijit.form.Form to add Crud functionality.  You create
		//   your forms as dojo enriched HTML forms (a <form dojoType="ppwcode.dojo.dijit.form.CrudForm"></form>
		//   with dijit form widgets, such as dijit.form.TextBox in it). The form offers
		//   the same functionality as the dijit.form.Form, adds CRUD viewing modes,
		//   allows to automatically display javascript objects in the form and provides
		//   an easy way to update and create new javascript objects.
        // description:
		//   1) Viewing modes
		//
		//   The form supports 3 viewing modes, View mode, Create mode and Update mode.  Each viewing mode
		//   changes the status of the input fields in the form and displays a number of buttons that apply
		//   for that viewing mode.  In View mode, all fields are disabled (i.e. not editable), and two buttons
		//   are shown: an edit button and an optional delete button (the delete button is enabled by setting
		//   the withDelete attribute of the CrudForm to true).  Clicking the Edit button will put the form
		//   in Update mode.
		//
		//   In Update mode, all form input fields are enabled (editable) and another set of
		//   Buttons are placed under the form:  An Update button and a Cancel button.  Clicking the Update
		//   button will make the buttons disappear and generate the onUpdateModeSaveButtonClick() event,
		//   which can be overridden by the form user, the buttons disappear.  The Cancel button will undo
		//   all changes made and put the form back in View mode.
		//
		//   Create mode will be reset the form fields (the form will be empty) and display a Create button and
		//   a Cancel button.  Clicking the Cancel button does not return to View Mode; it will reset the form
		//   and remove the buttons.  Clicking the create button will make the buttons disappear and generate the
		//   onCreateModeSaveButtonClick() event.
		//
		//
		//   2) Display a javascript object in the form.
		//
		//   Although the view modes can be manipulated explicitly, the main goal of the form is to provide improved
		//   support for Creating, Updating and Deleting of arbitrary javascript Objects.  The core functionality
		//   lies in the event handlers for save and update operations and the ability to display the values of a
		//   particular javascript object in a straightforward way.
		//
		//   The main business operations that a javascript program can call on the CrudForm are createObject() and
		//   displayObject(object).  Calling createObject() puts the form in Create mode.  Calling displayObject will
		//   display the object passed along as a parameter and put the form in View mode.  To be able to display
		//   an object, the CrudForm must know how to map the properties of an object to the fields in the form.
		//   This is done by setting the fromMap (setFormMap(map)) of the CrudForm.  a formMap is array of
		//   mapping objects:
		//
		//   var formmap = [{property: "prop1", fieldId: "textfield1", isId: true},
		//                  {property: "prop2", fieldId: "hiddenfield1},
		//                   ...
		//                  {property: "propJ1.propJ2", fieldId: "somefieldJ", constructorFunction: funcJ, isEditable: false},
		//                   ...
		//                  {property: "propN", feieldId: "datefieldN"}];
		//
		//   Each mapping object must contain 2 properties:  a "property" and a "fieldid".  The "property" must be
		//   the name of a property of the object you will be displaying, the fieldid must be the HTML ID of an
		//   input field in the form.  You're obviously not required to display all properties of an object, only
		//   those in the formmap will be displayed.  There is one additional property of the mapping object: "isId".
		//   this marks a property of the object as a property that can be used to identify the property.  the value
		//   of the isId property must always be a boolean.  The form does not use the isId property, but can make
		//   identity information available to create or update handlers that need that information;
		//   the getObjectIdFields() method returns an array of all the property names that were marked as "isId".
		//
		//
		//   3) Creating and updating objects
		//
		//   the onUpdateModeSaveButtonClick and onSaveModeSaveButtonClick event handlers are called when
		//   the Update or Create buttons are clicked.  Both event handlers pass along an event object as
		//   a parameter.  This event object corresponds to the click event that was generated by the browser
		//   when the button was clicked, with one additional property: "formObject".  This property contains
		//   the object that was created or updated in the form.  In case of creation, the object will be created
		//   by calling the function that was passed in the "constructorFunction" attribute of the CrudForm.
		//   (if it's not specified, the object will be created by issuing "new Object()").  Subsequently, all the
		//   values of the input fields will be assigned to the newly created object, adhering to the formMap.
		//   In case of updating, the original object is cloned (using dojo.clone, so no loops in the object
		//   graph allowed), and the form fields are assigned to the appropriate object properties.

		//override templateString from superclass.
		//Note:  templateString must be defined BEFORE templatePath, templatePath is replaced by templateString
		//       when doing a dojo custom build.
		templateString: null,
		templatePath: dojo.moduleUrl("ppwcode", "dojo/dijit/form/templates/CrudForm.html"),

		constructorFunction: null,

		withDelete: false,

		_viewModeButtonPanel: null,
		_viewModeEditButton: null,
		_viewModeDeleteButton: null,

		_createModeButtonPanel: null,
		_createModeSaveButton: null,
		_createModeCancelButton: null,

		_updateModeButtonPanel: null,
		_updateModeSaveButton: null,
		_updateModeCancelButton: null,

		//busyicon is overridable through attribute
		busyicon: dojo.moduleUrl("ppwcode.dojo.dijit.form", "resources/icons/loading.gif"),
	
		_savingMessagePanel: null,
		_updatingMessagePanel: null,

		_tooltips: null,

		//the masterview, if there is one.
		_masterview: null,

		_thebuttoncontainer: null,
		
		_localizationbundle: null,
		
		
		constructor: function() {
 			this._tooltips = new Object();

			this._localizationbundle = dojo.i18n.getLocalization("ppwcode.dojo.dijit.form", "CrudForm");
			//View Button Panel
			this._viewModeButtonPanel = dojo.doc.createElement('div');
			dojo.addClass(this._viewModeButtonPanel, "CrudFormButtonPanel");
			//Edit Button
			var tempButton = dojo.doc.createElement('button');
			this._viewModeButtonPanel.appendChild(tempButton);
			this._viewModeEditButton =
				new dijit.form.Button({
					label: this._localizationbundle.editButtonLabel
				}, tempButton);
			this._viewModeEditButton.startup();

			//Create Button Panel
			this._createModeButtonPanel = dojo.doc.createElement('div');
			dojo.addClass(this._createModeButtonPanel, "CrudFormButtonPanel");
			//Create Button
			tempButton = dojo.doc.createElement('button');
			this._createModeButtonPanel.appendChild(tempButton);
			this._createModeSaveButton =
				new dijit.form.Button({
					label: this._localizationbundle.saveButtonLabel
				}, tempButton);
			this._createModeSaveButton.startup();
			//Cancel button
			tempButton = dojo.doc.createElement('button');
			this._createModeButtonPanel.appendChild(tempButton);
			this._createModeCancelButton =
				new dijit.form.Button({
					label: this._localizationbundle.cancelButtonLabel
				}, tempButton);
			this._createModeSaveButton.startup();

			//Update Button Panel
			this._updateModeButtonPanel = dojo.doc.createElement('div');
			dojo.addClass(this._updateModeButtonPanel, "CrudFormButtonPanel");
			//Create Button
			tempButton = dojo.doc.createElement('button');
			this._updateModeButtonPanel.appendChild(tempButton);
			this._updateModeSaveButton =
				new dijit.form.Button({
					label: this._localizationbundle.updateButtonLabel
				}, tempButton);
			this._createModeSaveButton.startup();
			//this._createModeButtonPanel.appendChild(spacer);
			//Cancel button
			tempButton = dojo.doc.createElement('button');
			this._updateModeButtonPanel.appendChild(tempButton);
			this._updateModeCancelButton =
				new dijit.form.Button({
					label: this._localizationbundle.cancelButtonLabel
				}, tempButton);
			this._updateModeSaveButton.startup();
			
			//Status panels
			this._savingMessagePanel = dojo.doc.createElement('div');
			dojo.addClass(this._savingMessagePanel, "CrudFormBusyPanel");
			var tmpimg = dojo.doc.createElement('img');
			dojo.attr(tmpimg, {src: this.busyicon, alt: ""});
			dojo.addClass(tmpimg, "CrudFormBusyIcon");
			this._savingMessagePanel.appendChild(tmpimg);
			var tmpmessage = dojo.doc.createElement('span');
			dojo.addClass(tmpmessage, "CrudFormBusyMessage");
			tmpmessage.innerHTML = this._localizationbundle.savingMessage;
			this._savingMessagePanel.appendChild(tmpmessage);

			this._updatingMessagePanel = dojo.doc.createElement('div');
			dojo.addClass(this._updatingMessagePanel, "CrudFormBusyPanel");
			tmpimg = dojo.doc.createElement('img');
			dojo.attr(tmpimg, {src: this.busyicon, alt: ""});
			dojo.addClass(tmpimg, "CrudFormBusyIcon");
			this._updatingMessagePanel.appendChild(tmpimg);
			tmpmessage = dojo.doc.createElement('div');
			dojo.addClass(tmpmessage, "CrudFormBusyMessage");
			tmpmessage.innerHTML = this._localizationbundle.updatingMessage;
			this._updatingMessagePanel.appendChild(tmpmessage);
		},

		postMixInProperties: function(){
			//connect buttons
			this.inherited(arguments);
			dojo.connect(this._viewModeEditButton, "onClick", this, "_onviewmodeeditbuttonclick");
			dojo.connect(this._updateModeSaveButton, "onClick", this, "_onupdatemodesavebuttonclick");
			dojo.connect(this._updateModeCancelButton, "onClick", this, "_onupdatemodecancelbuttonclick");
			dojo.connect(this._createModeSaveButton, "onClick", this, "_oncreatemodesavebuttonclick");
			dojo.connect(this._createModeCancelButton, "onClick", this, "_oncreatemodecancelbuttonclick");

			var localizationbundle = dojo.i18n.getLocalization("ppwcode.dojo.dijit.form", "CrudForm");

			if (this.withDelete === true) {
				var tempButton = dojo.doc.createElement('button');
				this._viewModeButtonPanel.appendChild(tempButton);
				this._viewModeDeleteButton =
					new dijit.form.Button({
						label: this._localizationbundle.deleteButtonLabel
					}, tempButton);
				this._viewModeDeleteButton.startup();
				dojo.connect(this._viewModeDeleteButton, "onClick", this, "_onviewmodedeletebuttonclick");
			}
		},

		buildRendering: function() {
			this.inherited(arguments);
			this._errorMessagesNode = dojo.doc.createElement('div');
			dojo.addClass(this._errorMessagesNode, "CrudFormError");
			dojo.place(this._errorMessagesNode, this.containerNode, "after");
		},
		
		startup: function() {
			if (this.domNode.parentNode) {
				dojo.connect(this.domNode.parentNode, "onscroll", this, this._redrawTooltips);
			}
			this.inherited(arguments);
		},
		
		onSubmit: function(/*Event*/e){
			//this form should normally never be submitted
			console.log("CrudForm.onSubmit called");
			return false;
		},

		setButtonContainerNode: function(/*String*/btncontainername) {
			this._thebuttoncontainer = dojo.byId(btncontainername);
		},

		_displayButtons: function(panel) {
			if (this._thebuttoncontainer) {
				this._thebuttoncontainer.appendChild(panel);
			} else {
				this.buttonContainerNode.appendChild(panel);
			}
		},

		/////////////////////////// GUI handling ///////////////////////


		//remove button panel
		_setInitMode: function() {
			if (this._thebuttoncontainer) {
				dojo.query(".CrudFormButtonPanel", this._thebuttoncontainer).orphan();
				dojo.query(".CrudFormBusyPanel", this._thebuttoncontainer).orphan();
			} else {
				dojo.query(".CrudFormButtonPanel", this.buttonContainerNode).orphan();
				dojo.query(".CrudFormBusyPanel", this._thebuttoncontainer).orphan();
			}
			this._disableFormFields(true);
  		},


		setViewMode: function() {
			// summary:
			//   Set the form in view mode
			// description:
			//   In view mode, the buttons shown are "Edit" and optionally "Delete".  The fields
			//   are disabled.  Note that the contents of the input fields is not modified.
			this._setInitMode();
			this._displayButtons(this._viewModeButtonPanel);
			this._disableFormFields(true);
		},

		setUpdateMode: function() {
			// summary:
			//   Set the form in update mode.
			// description:
			//   In view mode, the buttons shown are "Update" and "Cancel".  The fields
			//   are disabled.  The contents of the input fields is not modified.
			this._setInitMode();
			this._displayButtons(this._updateModeButtonPanel);
			this._disableFormFields(false);
		},

		setCreateMode: function(/*Object?*/prototype) {
			// summary:
			//   Set the form in create mode.
			// description:
			//   In view mode, the buttons shown are "Create" and "Cancel".  The fields
			//   are disabled.  The content of the input fields are cleared
			this.reset();
			if (prototype) {
				this._displayObject(prototype);
			}
			this.setCreateModeNoReset();
		},

		setCreateModeNoReset: function() {
			this._setInitMode();
			this._displayButtons(this._createModeButtonPanel);
			this._disableFormFields(false);
		},
		//////////////////////// Button Events /////////////////////////

		_onviewmodeeditbuttonclick: function(/*Event*/e) {
			this.setUpdateMode();
            this.onViewModeEditButtonClick(e);
		},

		_onviewmodedeletebuttonclick: function(/*Event*/e) {
			this._setInitMode();
			e.formObject = dojo.clone(this._thedisplayobject);
			this.onViewModeDeleteButtonClick(e);
		},

		_onupdatemodesavebuttonclick: function(/*Event*/e) {
			this._setInitMode();
			this._displayButtons(this._updatingMessagePanel);
			var obj = dojo.clone(this._thedisplayobject);
			e.formObject = this._createOrUpdateObjectFromForm(obj);
			this.onUpdateModeSaveButtonClick(e);
		},

		_onupdatemodecancelbuttonclick: function(/*Event*/e) {
			//reset fields.  createObject does not set
			this.displayItem(this._thedisplayobject);
			this.setViewMode();
            this.onUpdateModeCancelButtonClick(e);
		},

		_oncreatemodesavebuttonclick: function(/*Event*/e) {
			if (this.validate()) {
			  this._setInitMode();
				this._displayButtons(this._savingMessagePanel);
			  //decorate the event with the new object
			  if (this._thedisplayobject) {
				  e.formObject = this._createOrUpdateObjectFromForm(this._thedisplayobject);
			  } else {
				  e.formObject = this._createOrUpdateObjectFromForm(new this.constructorFunction());
			  }
			  this.onCreateModeSaveButtonClick(e);
			} else {
              dojo.stopEvent(e);
            }
		},

		_oncreatemodecancelbuttonclick: function(/*Event*/e) {
			this.reset();
			this.onCreateModeCancelButtonClick(e);
		},

		_createOrUpdateObjectFromForm: function(/*Object*/obj) {
			//process all defined fields
			for (var fieldid in this._byFieldIdMap) {
				//if a field is not editable, we ignore it.
				if (this._byFieldIdMap[fieldid].isEditable) {
					//this will at least give a list of length 1.
					var proplist = this._byFieldIdMap[fieldid].property.split('.');
					var edit = obj;
					for (var i = 0; i < proplist.length - 1; i++) {
						var prop = proplist[i];
						//if propname does not exist, and it's not the property we will be
						//assigning to, indicating we must travel further down the object
						//graph, we create an object.
						if ( (edit[prop] === undefined) && (i < proplist.length - 2)) {
							edit[prop] = new Object();
						}
						edit = edit[prop];
					}
					//console.log("editing property " + this._byFieldIdMap[fieldid].property);
					edit[proplist[proplist.length - 1]] = this._byFieldIdMap[fieldid].widget.attr('value');
				}
			}
			return obj;
		},

		_redrawTooltips: function() {
			for (var props in this._tooltips) {
				this._tooltips[props].hide(this._tooltips[props].__PpwNode);
				this._tooltips[props].show(this._tooltips[props].__PpwMessage, this._tooltips[props].__PpwNode);
			}
		},
		
		// resize will only be called when it is an immediate child of a
		// layout widget.  In case of a ContentPane, it must even be the
		// only child...
		resize: function() {
			//console.log("CrudForm: resize()!!");
			this._redrawTooltips();
 		},

		///////////////////// Public Button Events /////////////////////////

		onUpdateModeSaveButtonClick: function(/*Event*/ e) {
 			// summary:
 			//    override function:  called when the Save button in Update mode is clicked.
 			// description:
 			//    override function:  called when the Save button in Update mode is clicked.
 			// e:
 			//    DOM event
		},

		onCreateModeSaveButtonClick: function(/*Event*/ e) {
 			// summary:
 			//    override function:  called when the Save button is clicked in Create mode.
 			// description:
 			//    override function:  called when the Save button is clicked in Create mode.
 			// e:
 			//    DOM event
		},

		onViewModeDeleteButtonClick: function(/*Event*/ e) {
 			// summary:
 			//    override function:  called when the Delete button is clicked in View mode.
 			// description:
 			//    override function:  called when the Delete button is clicked in View mode.
 			// e:
 			//    DOM event
		},

        onViewModeEditButtonClick: function(/*Event*/ e) {
            // summary:
 			//    override function:  called when the Edit button is clicked in View mode.
 			// description:
 			//    override function:  called when the Edit button is clicked in View mode.
 			// e:
 			//    DOM event
        },

        onUpdateModeCancelButtonClick: function(/*Event*/ e) {
            // summary:
 			//    override function:  called when the Cancel button is clicked in Update mode.
 			// description:
 			//    override function:  called when the Cancel button is clicked in Update mode.
 			// e:
 			//    DOM event
        },

        onCreateModeCancelButtonClick: function(/*Event*/ e) {
            // summary:
 			//    override function:  called when the Cancel button is clicked in Create mode.
 			// description:
 			//    override function:  called when the Cancel button is clicked in Create mode.
 			// e:
 			//    DOM event
        },
		// Business Methods...

		reset: function() {
			// summary:
			//    Resets the form.
			// description:
			//    Clear the input fields of the form and remove possible error messages
        	this.removeAllErrorMessages();
			this._setInitMode();
			this.inherited(arguments);
			
			// XXX MUDO TOM: check if this meets your needs !!
			// setting all fields to empty, where as now we sometimes see 'undefined' or 'null' in the field
			for (var fieldid in this._byFieldIdMap) {
				//this._byFieldIdMap[fieldid].widget.reset();
				this._byFieldIdMap[fieldid].widget.attr('value', "");
			}
        },

        displayItem: function(obj) {
        	this.inherited(arguments);
			this.setViewMode();
		},

        		
		createObject: function(/*Object?*/prototype) {
			// summary:
			//    Prepare the form to create a new object.
			// description:
			//    This is equivalent to setting the form in createmode
			this.setCreateMode(prototype);
		},

		getConstructorFunction: function() {
			return this.constructorFunction;
		},
		

		_hideErrorMessage: function(/*String*/property) {
			var tip = this._tooltips[property];
			tip.hide(tip.__PpwNode);
			while (tip.__PpwConnectHandle.length > 0) {
				dojo.disconnect(tip.__PpwConnectHandle.pop());
			}
			// hiding does not delete the dom node 
			tip.domNode.parentNode.removeChild(tip.domNode);
			delete this._tooltips[property];
		},

		removeAllErrorMessages: function() {
			for (var property in this._tooltips) {
				this._hideErrorMessage(property);
			}
			dojo.removeClass(this._errorMessagesNode, "CrudFormErrorBox");
			dojo.query("> ", this._errorMessagesNode).orphan();
		},
		
		_addErrorMessage: function(message) {
			var query = dojo.query("> ul", this._errorMessagesNode);
			var messageslist = null;
			if (query.length != 0) {
				messageslist = query[0];
			} else {
				dojo.addClass(this._errorMessagesNode, "CrudFormErrorBox");
				var title = dojo.doc.createElement('div');
				dojo.addClass(title, "CrudFormErrorBoxTitle");
				title.innerHTML = this._localizationbundle.errorBoxTitle;
				this._errorMessagesNode.appendChild(title);
				messageslist = dojo.doc.createElement('ul');
				this._errorMessagesNode.appendChild(messageslist);
			}
			var messagenode = dojo.doc.createElement('li');
			messagenode.innerHTML = message;
			messageslist.appendChild(messagenode);
		},
		
		_displayPropertyErrorMessage: function(property, errormessage) {
			var tt = new dijit._MasterTooltip();
			var formwidget = this._byPropertyNameMap[property].widget;

			//styling of error contents
			dojo.addClass(tt.containerNode, "CrudFormError");
			//no fading
			tt.duration = 1;
			//needed to recreate the fade functions
			tt.postCreate();
			//let's just cache the node and the message in the tooltip, so
			//we can reference them when resizing.
			tt.__PpwNode = this._byPropertyNameMap[property].domNode;
			tt.__PpwMessage = errormessage;

			//attach to some events on the form field to make the tip disappear
			tt.__PpwConnectHandle = new Array();
			//every _Widget has an onChange method
			tt.__PpwConnectHandle.push(
				dojo.connect(
					formwidget,
					"onChange",
					null,
					dojo.hitch(this, this._hideErrorMessage, property)
				)
			);
			//FormValueWidgets have an _onKeyPress Method... private or not... we
			//attach to it, so we can hide the errormessage on first keypress.
			if (formwidget._onKeyPress && dojo.isFunction(formwidget._onKeyPress)) {
				tt.__PpwConnectHandle.push(
					dojo.connect(
						formwidget,
						"_onKeyPress",
						null,
						dojo.hitch(this, this._hideErrorMessage, property)
					)
				);
			}
			this._tooltips[property] = tt;
			//show the tooltip
			tt.show(tt.__PpwMessage, tt.__PpwNode, ["after", "before", "above"]);
			
		},
		
		displayErrorMessages: function(/*Object[]*/messages) {
			// summary:
			//    display error messages on the form using Dojo ToolTip widgets
			// description:
			//    display error messages on the form using Dojo ToolTip widgets.
			//    These messages are different from the typical input field
			//    validation messages in that they typically come from the server.
			//    This method provides a means to display error messages that
			//    result from server side form validation.
			// messages:
			//    an array of messages.  The array consists of objects that
			//    must have the following properties:  "propertyName" (optional) and
			//    "localizedMessage".  For example:
			//    [ {propertyName: "name", localizedMessage: "name is not unique"},
			//      {propertyName: "e-mail", localizedMessage: "the domain name for this email address does not exist."}]

			//remove old messages if any
			this.removeAllErrorMessages();

			for (var i = 0; i < messages.length; i++) {
				if (messages[i].propertyName && this._byPropertyNameMap[messages[i].propertyName]) {
					this._displayPropertyErrorMessage(messages[i].propertyName, messages[i].localizedMessage);
				} else {
					this._addErrorMessage(messages[i].localizedMessage);
				}
			}	
		},
		
		displayPropertyException: function(/*PropertyException*/propertyexception) {
			if ((propertyexception instanceof CompoundPropertyException) 
				|| (propertyexception instanceof CompoundSemanticException)){
				this.displayErrorMessages(propertyexception.elementExceptions);
			} else {
				this.displayErrorMessages([propertyexception]);
			}
		}
	}
);